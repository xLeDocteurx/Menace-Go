package main
// TO DO Une vraie gestion d'erreurs non cassantes

import (
	// "unsafe"
	"os"
    "io/ioutil"
	"log"
	"fmt"
	// "reflect"
    "strings"
    "strconv"
    "encoding/json"
	// "encoding/binary"
	"time"
	// "image"
	// "image/draw"
	// "image/color"
	// "math"
	// "math/rand"

	"github.com/gofiber/fiber/v2"
    "github.com/gofiber/template/html"
	"github.com/gofiber/swagger"
	// docs are generated by Swag CLI, you have to import them.
	// replace with your own docs folder, usually "github.com/username/reponame/docs"
	_ "github.com/xLeDocteurx/Menace-Go/docs"

	// "gocv.io/x/gocv"
	// "github.com/gordonklaus/portaudio"
	// "github.com/xthexder/go-jack"
	// "github.com/gofiber/fiber/v2"
	// "go.mongodb.org/mongo-driver/mongo"
)

const defaultMicId = 1

func check(message string, err error) {
	if err != nil {
		fmt.Printf("check() err : " + message)
        log.Fatal(err)
	}
}

// @title Maia Google MicroService
// // @version 1.0
// @description This service (maia-google-ms) is the link between maia and google APIs
// // @termsOfService http://swagger.io/terms/
// // @contact.name API Support
// // @contact.email fiber@swagger.io
// // @license.name Apache 2.0
// // @license.url http://www.apache.org/licenses/LICENSE-2.0.html
// // @host localhost:8080
// @BasePath /
func main() {
	fmt.Println("App is Starting...")

    files, err := ioutil.ReadDir("./static")
	check("ioutil.ReadDir : ", err)
	fmt.Println("len(files) : ", len(files))
	fmt.Println("files : ", files)
	var txtFiles = []string{}
    for _, file := range files {
		if (!file.IsDir() && strings.Contains(file.Name(), ".txt")) {
			txtFiles = append(txtFiles, file.Name())
		}
    }

	var gameEngine GameEngine
	if(len(files) > 0) {
		binaryContent, err := ioutil.ReadFile("./static/" + txtFiles[0])
		check("ioutil.ReadFile : ", err)
		// stringContent := string(binaryContent)
		jsonContent := GameEngine{}
		if err = json.Unmarshal(binaryContent, &jsonContent); err != nil {
			fmt.Println("err : ", err)
		}
		// fmt.Println("jsonContent : ", jsonContent)
		gameEngine = NewGameEngineWithSave(jsonContent)
	} else {
		gameEngine = NewGameEngine()
	}
	// fmt.Println("gameEngine : ", gameEngine)



    // Initialize standard Go html template engine
    engine := html.New("./views", ".html")
	// app := fiber.New()
    app := fiber.New(fiber.Config{
        Views: engine,
    })

	app.Get("/swagger/*", swagger.HandlerDefault) // default

	// app.Get("/swagger/*", swagger.New(swagger.Config{ // custom
	// 	URL: "http://example.com/doc.json",
	// 	DeepLinking: false,
	// 	// Expand ("list") or Collapse ("none") tag groups by default
	// 	DocExpansion: "none",
	// 	// Prefill OAuth ClientId on Authorize popup
	// 	OAuth: &swagger.OAuthConfig{
	// 		AppName:  "OAuth Provider",
	// 		ClientId: "21bb4edc-05a7-4afc-86f1-2e151e4ba6e2",
	// 	},
	// 	// Ability to change OAuth2 redirect uri location
	// 	OAuth2RedirectUrl: "http://localhost:8080/swagger/oauth2-redirect.html",
	// }))

	// contains index.html outside the app folder
	app.Static("/", "./static")

	// Gameloop endpoints
	app.Get("/", func(c *fiber.Ctx) error {
		startGameRes := gameEngine.startGame(c)
		// fmt.Println("startGameRes : ", startGameRes)

		DoILive, err := json.Marshal(startGameRes.DoILive)
		if err != nil {
			return err
		}
		WhoStartsFirst, err := json.Marshal(startGameRes.WhoStartsFirst)
		if err != nil {
			return err
		}
		StatesJSON, err := json.Marshal(startGameRes.States)
		if err != nil {
			return err
		}
		StatsJSON, err := json.Marshal(startGameRes.Stats)
		if err != nil {
			return err
		}

        // Render index template
        return c.Render("index", fiber.Map{
            "DoILive": string(DoILive),
            "WhoStartsNext": string(WhoStartsFirst),
			"States": string(StatesJSON),
			"Stats": string(StatsJSON),
        })
	})
	app.Post("/", func(c *fiber.Ctx) error {
		// c.Accepts("application/json") // "application/json"
		payload := EndGameReq{}
		if err := json.Unmarshal(c.Body(), &payload); err != nil {
			fmt.Println("err : ", err)
			return c.SendString(err.Error())
		}
		// fmt.Println("payload after : ", payload)
		// fmt.Println("payload.Winner : ", payload.Winner)
		// fmt.Println("payload.History : ", payload.History)

		gameEngine.endGame(payload.Winner, payload.History)
		// fmt.Println("endGameRes : ", endGameRes)
		return c.SendString("endGameRes")
	})

	// @Summary Gracefully Shut Down
	// @Description Gracefully Shut Down : first test
	// @Tags EDI
	// @Accept */*
	// // @Produce json
	// @Success 200 {object} string
	// @Router /edi/configuration/global/gracefulShutdown [get]
	app.Get("/stats", func(c *fiber.Ctx) error {
		statsJSON, err := json.Marshal(gameEngine.makeStats())
		if err != nil {
			return err
		}
		return c.SendString(string(statsJSON))
	})

	// @Summary Gracefully Shut Down
	// @Description Gracefully Shut Down : first test
	// @Tags EDI
	// @Accept */*
	// // @Produce json
	// @Success 200 {object} string
	// @Router /edi/configuration/global/gracefulShutdown [get]
	app.Get("/states", func(c *fiber.Ctx) error {
		statesJSON, err := json.Marshal(gameEngine.States)
		if err != nil {
			return err
		}
		return c.SendString(string(statesJSON))
	})

	// @Summary Gracefully Shut Down
	// @Description Gracefully Shut Down : first test
	// @Tags EDI
	// @Accept */*
	// // @Produce json
	// @Success 200 {object} string
	// @Router /edi/configuration/global/gracefulShutdown [get]
	app.Get("/history", func(c *fiber.Ctx) error {
		historyJSON, err := json.Marshal(gameEngine.EndGameReqs)
		if err != nil {
			return err
		}
		return c.SendString(string(historyJSON))
	})

	// @Summary Gracefully Shut Down
	// @Description Gracefully Shut Down : first test
	// @Tags EDI
	// @Accept */*
	// // @Produce json
	// @Success 200 {object} string
	// @Router /edi/configuration/global/gracefulShutdown [get]
	app.Get("/save", func(c *fiber.Ctx) error {
		fileName := gameEngine.saveGameEngine()
		if err != nil {
			return err
		}
		return c.SendString("OK : " + fileName)
	})

	// gameEngine.saveGameEngine()
	go func() {
		for range time.NewTicker(time.Hour).C {
			gameEngine.saveGameEngine()
		}
	}()
	app.Listen(":3000")
	fmt.Println("Server listening on port 3000")

	// charset := []string{"0", "1", "2"}
	// res := []string{}
	// goDeeper(func (value string) {
	// 	fmt.Println("value : ", value)
	// 	res = append(res, value)
	// }, charset, 9 - 1, "")
	// // }, charset, 9 - 1, "")
	// fmt.Println("len(res) : ", len(res))
	// fmt.Println("res : ", res)


	fmt.Println("This app is Exiting...")
}

// STRUCTS
func NewGameEngine() GameEngine {
	fmt.Println("NewGameEngineWithSave")
	whoStartsNext := "human"
	var states []State
	charset := []string{"0", "1", "2"}
	goDeeper(func (value string) {
		state := NewState(value)
		states = append(states, state)
	}, charset, 9 - 1, "")
	
	fmt.Println("states length : ", len(states))

	return GameEngine{
		whoStartsNext,
		states,
		[]EndGameReq{},
	}
}
func NewGameEngineWithSave(save GameEngine) GameEngine {
	fmt.Println("NewGameEngineWithSave")
	fmt.Println("save.States length : ", len(save.States))
	return GameEngine{
		save.WhoStartsNext,
		save.States,
		save.EndGameReqs,
	}
}
type GameEngine struct {
	WhoStartsNext string
	States []State
	EndGameReqs []EndGameReq
}
func (this *GameEngine) makeStats() map[string]string {
	stats := make(map[string]string)

	stats["numberOfGamesPlayed"] = strconv.Itoa(len(this.EndGameReqs))
	humanWinsCount := 0
	robotWinsCount := 0
	drawCount := 0
	
	for i := range this.EndGameReqs {
		if this.EndGameReqs[i].Winner == "human"  {
			humanWinsCount += 1
		} else if this.EndGameReqs[i].Winner == "robot" {
			robotWinsCount += 1
		} else if this.EndGameReqs[i].Winner == "draw" {
			drawCount += 1
		}
	}

	stats["humanWinsCount"] = strconv.Itoa(humanWinsCount)
	stats["robotWinsCount"] = strconv.Itoa(robotWinsCount)
	stats["drawCount"] = strconv.Itoa(drawCount)
	// stats["winRate"] = fmt.Sprintf("%f", float64(robotWinsCount) / float64(len(this.EndGameReqs)), 64)
	stats["winRate"] = fmt.Sprintf("%f", (float64(robotWinsCount) / (float64(robotWinsCount) + float64(humanWinsCount))) * 100, 64)

	return stats
}
func (this *GameEngine) doILive() bool {
	return true
}
func (this *GameEngine) startGame(c *fiber.Ctx) StartGameRes {
	stats := this.makeStats()

	humanWinsCount := 0
	robotWinsCount := 0
	drawCount := 0
	
	for i := range this.EndGameReqs {
		if this.EndGameReqs[i].Winner == "human"  {
			humanWinsCount += 1
		} else if this.EndGameReqs[i].Winner == "robot" {
			robotWinsCount += 1
		} else if this.EndGameReqs[i].Winner == "draw" {
			drawCount += 1
		}
	}

	return StartGameRes{
		this.doILive(),
		this.WhoStartsNext,
		this.States,
		stats,
	}
}
func (this *GameEngine) endGame(winner string, history []Turn) {
	robotTurns := []Turn{}
    for i := range history {
        if history[i].WhosTurn == "robot" {
            robotTurns = append(robotTurns, history[i])
        }
    }
	
	fmt.Println("----------------------------------------")
	fmt.Println("winner : ", winner)
	fmt.Println("history : ", history)

	for i := range robotTurns {
		var currentStateIndex int
		for stateIndex, state := range this.States {
			if state.Id == robotTurns[i].CurrentState {
				fmt.Println("Index found in states list")
				currentStateIndex = stateIndex
			}
		}

		fmt.Println("robotTurns[" + strconv.Itoa(currentStateIndex) + "] : ", robotTurns[i])
		fmt.Println("this.States[currentStateIndex] before : ", this.States[currentStateIndex])
		if winner == "robot" {
			this.States[currentStateIndex].reward(robotTurns[i].ChosenMove)
		} else if winner == "human" {
			this.States[currentStateIndex].punish(robotTurns[i].ChosenMove)
		} else if winner == "draw" {
			// ?
		}
		fmt.Println("this.States[currentStateIndex] after : ", this.States[currentStateIndex])
	}

	this.EndGameReqs = append(this.EndGameReqs, EndGameReq{
		winner,
		history,
	})

	switch this.WhoStartsNext {
    case "robot":
		this.WhoStartsNext = "human"
    case "human":
		this.WhoStartsNext = "robot"
	}
}
func (this *GameEngine) saveGameEngine() string {
	fmt.Println("saveGameEngine")
	// File
	now := time.Now()
	file := "./static/" + strconv.Itoa(now.Year()) + "-" + strconv.Itoa(int(now.Month())) + "-" + strconv.Itoa(now.Day()) + "." + strconv.Itoa(now.Hour()) + "-" + strconv.Itoa(now.Minute()) + ".txt"

    f, err := os.Create(file)
    check("saveGameEngine() os.Create : ", err)
    defer f.Close()


	gameEngineJSON, err := json.Marshal(this)
    check("saveGameEngine() json.Marshal : ", err)

    _, err2 := f.WriteString(string(gameEngineJSON))
    check("saveGameEngine() f.WriteString : ", err2)

	fmt.Println("saveGameEngine done")
	// TO DO db

	return file
}

func NewState(id string) State {
	chars := []rune(id)
	weights := Weights{}

	// fmt.Println("string(chars) : ", string(chars))
	if string(chars[0]) == "0" {
		weights.A = 5
	}
	if string(chars[1]) == "0" {
		weights.B = 5
	}
	if string(chars[2]) == "0" {
		weights.C = 5
	}
	if string(chars[3]) == "0" {
		weights.D = 5
	}
	if string(chars[4]) == "0" {
		weights.E = 5
	}
	if string(chars[5]) == "0" {
		weights.F = 5
	}
	if string(chars[6]) == "0" {
		weights.G = 5
	}
	if string(chars[7]) == "0" {
		weights.H = 5
	}
	if string(chars[8]) == "0" {
		weights.I = 5
	}
	// fmt.Println("weights : ", weights)

	return State{
		id,
		weights,
	}
}
type State struct {
	Id string
	Weights Weights
}
func (this *State) reward(chosenMove string) {
	switch chosenMove {
	case "A":
		this.Weights.A += 2
	case "B":
		this.Weights.B += 2
	case "C":
		this.Weights.C += 2
	case "D":
		this.Weights.D += 2
	case "E":
		this.Weights.E += 2
	case "F":
		this.Weights.F += 2
	case "G":
		this.Weights.G += 2
	case "H":
		this.Weights.H += 2
	case "I":
		this.Weights.I += 2
	}
}
func (this *State) draw(chosenMove string) {
	switch chosenMove {
	case "A":
		this.Weights.A += 1
	case "B":
		this.Weights.B += 1
	case "C":
		this.Weights.C += 1
	case "D":
		this.Weights.D += 1
	case "E":
		this.Weights.E += 1
	case "F":
		this.Weights.F += 1
	case "G":
		this.Weights.G += 1
	case "H":
		this.Weights.H += 1
	case "I":
		this.Weights.I += 1
	}
}
func (this *State) punish(chosenMove string) {
	switch chosenMove {
	case "A":
		this.Weights.A -= 1
	case "B":
		this.Weights.B -= 1
	case "C":
		this.Weights.C -= 1
	case "D":
		this.Weights.D -= 1
	case "E":
		this.Weights.E -= 1
	case "F":
		this.Weights.F -= 1
	case "G":
		this.Weights.G -= 1
	case "H":
		this.Weights.H -= 1
	case "I":
		this.Weights.I -= 1
	}
}

// TYPES
type Weights struct {
	A int
	B int
	C int
	D int
	E int
	F int
	G int
	H int
	I int
}

type StartGameRes struct {
	DoILive bool
	WhoStartsFirst string
	States []State
	Stats map[string]string
}

type EndGameReq struct {
	Winner string
	History []Turn
}
type Turn struct {
	WhosTurn string
	CurrentState string
	ChosenMove string
}

// UTILS
func goDeeper(callback func(value string), charSet []string, k int, current string) {
	for i := 0; i < len(charSet); i++ {
		if k == 0 {
			// await requestSemaphore.acquire();
			res := current + charSet[i]

			charsMap := map[string]int{
				"0": 0,
				"1": 0,
				"2": 0,
			}
		
			for i := 0; i < len(res); i++ { 
				charsMap[string(res[i])] += 1; 
			} 
			condA := charsMap["1"] - charsMap["2"] < 2
			condB := charsMap["2"] - charsMap["1"] < 2

			if condA {
				if condB {
					callback(res); 
				}
			}
		} else {
			goDeeper(callback, charSet, k - 1, current + charSet[i])
		}   
	}
}
